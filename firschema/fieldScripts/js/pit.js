// Generated by CoffeeScript 1.6.3
(function() {
  var asbestos, code, comment, desc, description, firComment, firComments, fr19, fr20, fr21, fr22, fr23, fr24, fr25, fr26, fr27, getComment, getConduitBreakout, getSize, inroadway, k, key, mainArea, notLocated, notPerPlan, otherDamage, p, photoTaken, pit, pitNameChanged, remediationRequired, row, specID, statecode, statedesc, surfaceType, type, unfit, v, value, w, yMatrix, _i, _j, _len, _len1, _ref, _ref1, _ref10, _ref11, _ref12, _ref13, _ref14, _ref15, _ref16, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _ref8, _ref9,
    _this = this,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  w = new WebPage('ajl', "AJL");

  w.writeCode("/* Not Applicable for Transits.  Default value to 0 on FIR */</code>\najl = 0");

  w.end();

  asbestos = function(pit) {
    if (pit.asbestos === "Y") {
      return "Y";
    }
    return "";
  };

  w = new WebPage("asbestos", "Contains or may contain asbestos");

  w.writeCode(asbestos.toString());

  w.beginTable("oldpit.asbestos", "Result");

  _ref = codedValues.yesno;
  for (k in _ref) {
    v = _ref[k];
    p = old_pit[0];
    p.asbestos = k;
    w.addToTable(p.asbestos, asbestos(p));
  }

  w.endTable;

  w.end();

  w = new WebPage('breakout', "Breakout");

  w.writeCode("/* No need to populate */\nbreakout = \"\" ");

  w.end();

  getComment = function(code, value, firComment) {
    if (code === "127") {
      return firComment;
    } else {
      if (firComment.length > 0) {
        return value + ". " + firComment;
      } else {
        return value;
      }
    }
  };

  w = new WebPage("comments", "General Comments");

  w.writeCode(getComment.toString());

  w.beginTable("Code", "Value", "Non Standard Comment", "Comment");

  firComments = ["Custom non-standard comment", ""];

  _ref1 = codedValues.pitfirstandardcomments;
  for (code in _ref1) {
    value = _ref1[code];
    for (_i = 0, _len = firComments.length; _i < _len; _i++) {
      firComment = firComments[_i];
      w.addToTable(code, value, firComment, getComment(code, value, firComment));
    }
  }

  w.endTable();

  w.end();

  getConduitBreakout = function(pit) {
    var route;
    for (k in newugroute) {
      route = newugroute[k];
      if (pit.id === route.startnode) {
        return "Y";
      } else if (pit.id === route.endnode) {
        return "Y";
      }
    }
    return "";
  };

  w = new WebPage('conduitBreakout', "Conduit Breakout Required");

  w.writeCode(getConduitBreakout.toString());

  w.beginTable("Pit ID", "Conduit Breakout Required");

  _ref2 = old_pit.slice(10, 21);
  for (_j = 0, _len1 = _ref2.length; _j < _len1; _j++) {
    pit = _ref2[_j];
    w.addToTable(pit.id, getConduitBreakout(pit));
  }

  w.endTable();

  w.end();

  w = new WebPage('djl', "DJL");

  w.writeCode("/* Not Applicable for Transits.  Default value to 0 on FIR */\ndjl = 0");

  w.end();

  w = new WebPage('enclosureCount', "Enclosure Count");

  w.writeCode("/* The count of all of the transit joints i.e.\nif there were a TJL column in the template */\nenclosureCount = tjl");

  w.end();

  w = new WebPage('fda', "FDA");

  w.writeCode("/* Not Applicable for Transits */\nFDA = ''");

  w.end();

  w = new WebPage('fr19', "FR19 - Vehicle Splicing location not sufficiently close");

  fr19 = function(pit) {
    if (pit.scopestate === '30') {
      return 'Y';
    }
    return '';
  };

  w.writeCode(fr19.toString());

  w.beginTable("old_pit.scopestate", "Description", "Result");

  _ref3 = codedValues.oldpitscopestate;
  for (statecode in _ref3) {
    statedesc = _ref3[statecode];
    old_pit[0].scopestate = statecode;
    w.addToTable(statecode, statedesc, fr19(old_pit[0]));
  }

  w.endTable();

  w.end();

  fr20 = function(pit) {
    switch (pit.scopestate) {
      case "12":
      case "13":
      case "16":
      case "19":
        return "Y";
      default:
        return "";
    }
  };

  w = new WebPage('fr20', "FR20 - Not accessible by hand digging");

  w.beginTable("Domain", "Coded Value", "Return");

  w.writeCode(fr20.toString());

  _ref4 = codedValues.oldpitscopestate;
  for (k in _ref4) {
    v = _ref4[k];
    old_pit[0].scopestate = k;
    w.addToTable(k, v, fr20(old_pit[0]));
  }

  w.endTable();

  w.end();

  fr21 = function(pit) {
    switch (pit.scopestate) {
      case "10":
      case "11":
      case "15":
      case "16":
      case "17":
      case "18":
      case "19":
      case "20":
      case "25":
        return "Y";
      default:
        return "";
    }
  };

  w = new WebPage('fr21', "FR21 - Does not provide appropriate mechanical protection");

  w.writeCode(fr21.toString());

  w.beginTable("Domain", "Coded Value", "Return");

  _ref5 = codedValues.oldpitscopestate;
  for (k in _ref5) {
    v = _ref5[k];
    old_pit[0].scopestate = k;
    w.addToTable(k, v, fr21(old_pit[0]));
  }

  w.endTable();

  w.end();

  w = new WebPage('fr22', 'FR22 - In roadway and unable to withstand traffic');

  fr22 = function(pit) {
    if (pit.scopestate === "25") {
      return "Y";
    }
    return "";
  };

  w.writeCode(fr22.toString());

  old_pit[0].scopestate = "25";

  w.beginTable("old_pit.scopestate", "Description", "Result");

  w.addToTable(old_pit[0].scopestate, codedValues.oldpitscopestate[old_pit[0].scopestate], fr22(old_pit[0]));

  w.end();

  w = new WebPage('fr23', "FR23 - Not practical to install a Fibre Cable");

  fr23 = function(pit) {
    if (pit.scopestate === "29") {
      return "Y";
    }
    return "";
  };

  w.writeCode(fr23.toString());

  old_pit[0].scopestate = "29";

  w.beginTable("old_pit.scopestate", "Description", "Result");

  w.addToTable(old_pit[0].scopestate, codedValues.oldpitscopestate[old_pit[0].scopestate], fr23(old_pit[0]));

  w.end();

  w = new WebPage('fr24', "FR24 - Not structurally sound or not free of permanent water");

  fr24 = function(pit) {
    if (pit.scopestate === "22") {
      return "Y";
    }
    return "";
  };

  w.writeCode(fr24.toString());

  old_pit[0].scopestate = "22";

  w.beginTable("old_pit.scopestate", "Description", "Result");

  w.addToTable(old_pit[0].scopestate, codedValues.oldpitscopestate[old_pit[0].scopestate], fr24(old_pit[0]));

  w.end();

  w = new WebPage('fr25', "FR25 - Foreign matter obstructing Duct Section access point");

  fr25 = function(pit) {
    if (pit.scopestate === "23") {
      return "Y";
    }
    return "";
  };

  w.writeCode(fr25.toString());

  old_pit[0].scopestate = "23";

  w.beginTable("old_pit.scopestate", "Description", "Result");

  w.addToTable(old_pit[0].scopestate, codedValues.oldpitscopestate[old_pit[0].scopestate], fr25(old_pit[0]));

  w.end();

  w = new WebPage('fr26', "FR26 - Occupational, Health or Safety Risk");

  fr26 = function(pit) {
    if (pit.scopestate === "21") {
      return "Y";
    }
    return "";
  };

  w.writeCode(fr26.toString());

  old_pit[0].scopestate = "26";

  w.beginTable("old_pit.scopestate", "Description", "Result");

  w.addToTable(old_pit[0].scopestate, codedValues.oldpitscopestate[old_pit[0].scopestate], fr26(old_pit[0]));

  w.end();

  w = new WebPage('fr27', "FR27 - Insufficient Free capacity for Splice Enclosure");

  fr27 = function(pit) {
    var _ref6;
    if ((0 < (_ref6 = pit.scopestate) && _ref6 < 10)) {
      return "Y";
    } else {
      return "";
    }
  };

  w.writeCode(fr27.toString());

  w.beginTable("Domain", "Coded Value", "Return");

  _ref6 = codedValues.oldpitscopestate;
  for (k in _ref6) {
    v = _ref6[k];
    old_pit[0].scopestate = k;
    w.addToTable(k, v, fr27(old_pit[0]));
  }

  w.endTable();

  w.end();

  w = new WebPage('ljl', 'LJL');

  w.writeCode("/* Not Applicable for Transits.  Default value to 0 on FIR */\nljl = 0");

  w.end();

  w = new WebPage('mpt', 'MPT');

  w.writeCode("/* Not Applicable for Transits.  Default value to 0 on FIR *\nmpt = 0");

  w.end();

  notLocated = function(pit) {
    if (pit.scopestate === "24") {
      return "Y";
    } else {
      return "";
    }
  };

  w = new WebPage('notLocated', 'Not Located');

  w.writeCode(notLocated.toString());

  w.beginTable('Coded Value', 'Description', 'Return');

  _ref7 = codedValues.oldpitscopestate;
  for (code in _ref7) {
    desc = _ref7[code];
    old_pit[0].scopestate = code;
    w.addToTable(code, desc, notLocated(old_pit[0]));
  }

  w.endTable();

  w.end();

  w = new WebPage('notperplan', "Location Not As Per Planning Information");

  notPerPlan = function(pit) {
    return pit.notPerPlan.replace('N', '');
  };

  w.writeCode(notPerPlan.toString());

  w.beginTable("old_pit.notPerPlan", "Description", "Result");

  _ref8 = codedValues.yesno;
  for (code in _ref8) {
    desc = _ref8[code];
    old_pit[0].notPerPlan = code;
    w.addToTable(old_pit[0].notPerPlan, desc, notPerPlan(old_pit[0]));
  }

  w.endTable();

  w.end();

  w = new WebPage('otherDamage', "Other relevant physical damage");

  otherDamage = function(damagecolr, damagelid, damagepit) {
    var elements;
    elements = [];
    if (damagecolr === "Y") {
      elements.push("Collar");
    }
    if (damagelid === "Y") {
      elements.push("Lid");
    }
    if (damagepit === "Y") {
      elements.push("Pit Body");
    }
    switch (elements.length) {
      case 1:
        return "" + elements[0] + " damaged";
      case 2:
        return "" + elements[0] + " and " + elements[1] + " damaged";
      case 3:
        return "" + elements[0] + ", " + elements[1] + " and " + elements[2] + " damaged";
      default:
        return "";
    }
  };

  w.writeCode(otherDamage.toString());

  yMatrix = [["", "", ""], ["Y", "", ""], ["", "Y", ""], ["", "", "Y"], ["Y", "Y", ""], ["", "Y", "Y"], ["Y", "", "Y"], ["Y", "Y", "Y"]];

  w.beginTable("Collar", "Lid", "Pit", "Comment");

  for (k in yMatrix) {
    row = yMatrix[k];
    comment = otherDamage.apply(null, row);
    if (comment.length > 0) {
      row.push(comment);
      w.addToTable.apply(w, row);
    }
  }

  w.endTable();

  w.end();

  w = new WebPage('phototaken', "Photo Taken");

  photoTaken = function(pit) {
    return pit.phototaken.replace('N', '');
  };

  w.writeCode(photoTaken.toString());

  w.beginTable("old_pit.phototaken", "Description", "result");

  _ref9 = codedValues.yesno;
  for (code in _ref9) {
    desc = _ref9[code];
    old_pit[0].phototaken = code;
    w.addToTable(code, desc, photoTaken(old_pit[0]));
  }

  w.endTable();

  w.end();

  w = new WebPage('pitNameChanged', "Actual existing Pit size and type different from Planning information");

  pitNameChanged = function(pit) {
    if (tlspitname === !actpitname) {
      return "Y";
    }
    return "";
  };

  w.writeCode(pitNameChanged.toString());

  w.end();

  w = new WebPage('remediate', 'Remediate');

  w.writeCode("/* No need to populate */\nremediate = ''");

  w.end();

  w = new WebPage('remediationRequired', "Remediation Required");

  remediationRequired = function(pit) {
    var _ref10;
    if ((0 < (_ref10 = pit.scopestate) && _ref10 < 27)) {
      return "Y";
    } else {
      return "";
    }
  };

  w.writeCode(remediationRequired.toString());

  w.beginTable("Domain", "Coded Value", "Return");

  _ref10 = codedValues.oldpitscopestate;
  for (k in _ref10) {
    v = _ref10[k];
    old_pit[0].scopestate = k;
    w.addToTable(k, v, remediationRequired(old_pit[0]));
  }

  w.endTable();

  w.end();

  w = new WebPage("size", "Size");

  getSize = function(pit) {
    var description, digit, _ref11;
    description = codedValues.pitname[pit.tlspitname];
    digit = (_ref11 = description.match(/\d/)) != null ? _ref11[0] : void 0;
    switch (description) {
      case "Vic D":
        return "VD";
      case "X - Other":
        return "X";
      case "0":
        return "O";
    }
    if (description.match(/MH/) != null) {
      return "MH";
    }
    if (digit != null) {
      return digit;
    }
    return description;
  };

  w.writeCode(getSize.toString());

  w.beginTable("Telstra Pit Name", "Description", "Size");

  _ref11 = codedValues.pitname;
  for (k in _ref11) {
    v = _ref11[k];
    old_pit[0].tlspitname = k;
    w.addToTable(k, v, getSize(old_pit[0]));
  }

  w.endTable();

  w.end();

  specID = function(pit) {
    var description, longForm, pitCode, pitCodes, pitSize;
    description = codedValues.pitname[pit.tlspitname];
    pitCodes = {
      "J": "Injection Moulded",
      "H": "Hand Moulded",
      "P": "Thermoplastic",
      "PC": "Precast"
    };
    pitSize = description[description.search(/\d/)];
    pitCode = description[0];
    switch (pitCode) {
      case "C" && (pitSize != null):
        pitCode = "PC";
        break;
      case "V":
        pitSize = "D";
        break;
      case "0":
        pitCode = "O";
    }
    longForm = pitCodes[pitCode];
    switch (pitCode) {
      case "H":
      case "J":
      case "P":
      case "PC":
        return "Pit " + pitSize + ", " + pitCode + " (" + longForm + ")";
      case "V":
        return "Pit D, H (Hand Moulded - Vic)";
      case "M":
        return description.replace("MH", "Manhole");
      case "X":
        return "Other";
      case "N":
        return "Not Determined";
      default:
        return "Pit " + pitCode + ", H (Hand Moulded)";
    }
  };

  /*WRITING TO WEBPAGE*/


  w = new WebPage("specID", "Specification ID");

  w.writeCode(specID.toString());

  w.beginTable("Description", "Sentence");

  _ref12 = codedValues.pitname;
  for (key in _ref12) {
    description = _ref12[key];
    old_pit[0].tlspitname = key;
    w.addToTable(description, specID(old_pit[0]));
  }

  w.endTable();

  w.end();

  mainArea = function(pit) {
    var areas, largestNumber;
    areas = {
      "Unspecified": 0,
      "Grass": pit.bogoodturf,
      "Concrete": pit.boconcrete,
      "Bitumen": pit.bobituasph,
      "Paver": pit.bobrickpav
    };
    largestNumber = Math.max.apply(Math, (function() {
      var _results;
      _results = [];
      for (k in areas) {
        v = areas[k];
        _results.push(v);
      }
      return _results;
    })());
    return ((function() {
      var _results;
      _results = [];
      for (k in areas) {
        v = areas[k];
        if (v === largestNumber) {
          _results.push(k);
        }
      }
      return _results;
    })())[0];
  };

  surfaceType = function(pit) {
    var area;
    area = mainArea(pit);
    if (area === "Concrete" || area === "Bitumen") {
      if (pit.inroadway === "Y") {
        return area + " roadway";
      } else {
        return area + " footpath";
      }
    } else {
      return area;
    }
  };

  w = new WebPage('surfaceType', "Surface Type");

  w.writeCode(surfaceType.toString());

  w.writeWarning("The following table uses randomly generated values.  Refresh to try more values.");

  w.beginTable("pit.bogoodturf", "pit.boconcrete", "pit.bobituasph", "pit.bobrickpav", "Main Area", "In Roadway", "Return");

  _ref13 = old_pit.slice(0, 11);
  for (k in _ref13) {
    pit = _ref13[k];
    _ref14 = codedValues.yesno;
    for (inroadway in _ref14) {
      desc = _ref14[inroadway];
      pit.bogoodturf = Math.floor(Math.random() * 100);
      pit.boconcrete = Math.floor(Math.random() * 100);
      pit.bobituasph = Math.floor(Math.random() * 100);
      pit.bobrickpav = Math.floor(Math.random() * 100);
      pit.inroadway = inroadway;
      w.addToTable(pit.bogoodturf, pit.boconcrete, pit.bobituasph, pit.bobrickpav, mainArea(pit), pit.inroadway, surfaceType(pit));
    }
  }

  w.endTable();

  w.end();

  if (typeof document !== "undefined" && document !== null) {
    w = new WebPage("systemID", "System ID");
    code = "/* system_id not provided in NDD GML, default value to 0 on FIR */\nsystemID = 0";
    w.writeCode(code);
    w.end();
  }

  if (typeof document !== "undefined" && document !== null) {
    w = new WebPage("tls_id", "Telstra ID");
    w.writeCode("/* One to one translation */\ntls_id  = id");
    w.end();
  }

  type = function(pit) {
    description = codedValues.pitname[pit.tlspitname];
    if (v.match(/MH/)) {
      return "Manhole";
    } else {
      return "Pit";
    }
  };

  w = new WebPage('type', "Type");

  w.writeCode(type.toString());

  w.beginTable("Domain", "Coded Value", "Type");

  _ref15 = codedValues.pitname;
  for (k in _ref15) {
    v = _ref15[k];
    old_pit[0].tlspitname = v;
    w.addToTable(k, v, type(old_pit[0]));
  }

  w.endTable();

  w.end();

  unfit = function(pit) {
    var _ref16;
    if ((0 < (_ref16 = pit.scopestate) && _ref16 < 31)) {
      return "Y";
    } else {
      return "";
    }
  };

  w = new WebPage('unfit', "Unfit");

  w.writeCode(unfit.toString());

  w.beginTable("Domain", "Coded Value", "Return");

  _ref16 = codedValues.oldpitscopestate;
  for (k in _ref16) {
    v = _ref16[k];
    old_pit[0].scopestate = k;
    w.addToTable(k, v, unfit(old_pit[0]));
  }

  w.endTable();

  w.end();

  window.WebPage = (function() {
    function WebPage(divID, heading) {
      this.divID = divID;
      this.heading = heading;
      this.endTable = __bind(this.endTable, this);
      this.addToTable = __bind(this.addToTable, this);
      this.beginTable = __bind(this.beginTable, this);
      this.end = __bind(this.end, this);
      this.begin = __bind(this.begin, this);
      this.html = [];
    }

    WebPage.prototype.begin = function() {
      var d;
      document.querySelector(".span10").innerHTML += "<div id='" + divID + "'></div>";
      d = document.querySelector(".nav.nav-list");
      d.innerHTML += "<li><a href='#" + divID + "'>" + heading + "</a></li></ul>";
      this.html.push("<h2>" + this.heading + "</h2>");
      return this.html.push("<a href='./fieldScripts/coffee/" + this.divID + ".coffee'>Source Code Used To Generate Result</a>");
    };

    WebPage.prototype.end = function() {
      return document.getElementById("" + divID).innerHTML = this.html.join("");
    };

    WebPage.prototype.beginTable = function() {
      var heading, headings, table, _k, _len2;
      headings = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      this.html.push("<table class='table table-striped' width='200px'>");
      table = "<tr>";
      for (_k = 0, _len2 = headings.length; _k < _len2; _k++) {
        heading = headings[_k];
        table += "<th>" + heading + "</th>";
      }
      table += "</tr>";
      return this.html.push(table);
    };

    WebPage.prototype.addToTable = function() {
      var cell, cells, table, _k, _len2;
      cells = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      table = "<tr>";
      for (_k = 0, _len2 = cells.length; _k < _len2; _k++) {
        cell = cells[_k];
        table += "<td>" + cell + "</td>";
      }
      table += "</tr>";
      return this.html.push(table);
    };

    WebPage.prototype.endTable = function() {
      return this.html.push("</table>");
    };

    return WebPage;

  })();

}).call(this);
